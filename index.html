<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitwise Calc Pro</title>
    <style>
        :root {
            --bg-color: #111827;
            --card-bg: #1f2937;
            --text-main: #f3f4f6;
            --text-muted: #9ca3af;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --border: #374151;
            --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 540px; /* 조금 더 넓힘 */
        }

        h1 {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--text-main);
        }

        /* Mode Switcher */
        .mode-switch {
            display: flex;
            background-color: var(--bg-color);
            border-radius: 0.5rem;
            padding: 4px;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .mode-btn {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-muted);
            padding: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 0.3rem;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background-color: var(--accent);
            color: white;
        }

        /* Inputs Area */
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .input-row {
            display: flex;
            flex-direction: column;
        }

        .control-row {
            display: flex;
            gap: 1rem;
        }
        
        .control-item {
            flex: 1;
        }

        label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            font-weight: 500;
            display: block;
        }

        input[type="text"], select {
            background-color: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 1.1rem;
            font-family: var(--font-mono);
            width: 100%;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus, select:focus {
            border-color: var(--accent);
        }

        select {
            font-weight: bold;
            cursor: pointer;
            appearance: none; /* 네이티브 UI 제거 */
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1em;
        }

        input:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Result Area */
        .result-area {
            background-color: #0f131a;
            border-radius: 0.5rem;
            padding: 1.5rem;
            border: 1px solid var(--border);
            overflow-x: auto;
        }

        .calc-grid {
            display: grid;
            grid-template-columns: auto fit-content(100%) auto; /* Op, Bin, Dec */
            gap: 4px 15px;
            font-family: var(--font-mono);
            font-size: 1rem;
            line-height: 1.5;
        }

        .col-op {
            text-align: right;
            color: var(--accent);
            font-weight: bold;
            min-width: 25px;
        }

        .col-bin {
            text-align: right;
            color: var(--text-main);
            letter-spacing: 2px; /* 비트 간격 넓힘 */
            white-space: pre;
        }

        .col-dec {
            text-align: left;
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-left: 5px;
            white-space: nowrap;
        }

        .divider {
            grid-column: 1 / 4;
            border-bottom: 1px solid var(--text-muted);
            margin: 8px 0;
            opacity: 0.5;
        }

        .result-row .col-bin {
            color: var(--accent);
            font-weight: bold;
        }
        
        .result-row .col-dec {
            color: var(--accent);
        }

        /* Mobile Adjustments */
        @media (max-width: 480px) {
            .container { padding: 1.2rem; }
            .col-bin { font-size: 0.85rem; letter-spacing: 0.5px; }
            .col-dec { font-size: 0.75rem; }
            .control-row { gap: 0.5rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Bitwise Calc Pro</h1>

    <!-- Mode Switcher -->
    <div class="mode-switch">
        <button class="mode-btn active" id="btn-bin" onclick="setMode('BIN')">Binary (2진수)</button>
        <button class="mode-btn" id="btn-dec" onclick="setMode('DEC')">Decimal (10진수)</button>
    </div>

    <!-- Input Section -->
    <div class="input-group">
        <!-- Byte Size Selector & Operator Row -->
        <div class="control-row">
            <div class="control-item input-row">
                <label for="byteSize">데이터 크기</label>
                <select id="byteSize">
                    <option value="8">1 Byte (8-bit)</option>
                    <option value="16">2 Bytes (16-bit)</option>
                    <option value="32" selected>4 Bytes (32-bit)</option>
                    <option value="64">8 Bytes (64-bit)</option>
                </select>
            </div>
            <div class="control-item input-row">
                <label for="operator">연산자</label>
                <select id="operator">
                    <option value="&">AND (&amp;)</option>
                    <option value="|">OR (&#124;)</option>
                    <option value="^">XOR (^)</option>
                    <option value="~">NOT (~)</option>
                    <option value="<<">L-Shift (&lt;&lt;)</option>
                    <option value=">>">R-Shift (&gt;&gt;)</option>
                </select>
            </div>
        </div>

        <div class="input-row">
            <label for="inputA">값 A</label>
            <input type="text" id="inputA" placeholder="0" autocomplete="off">
        </div>

        <div class="input-row" id="row-inputB">
            <label for="inputB">값 B</label>
            <input type="text" id="inputB" placeholder="0" autocomplete="off">
        </div>
    </div>

    <!-- Result Section -->
    <div class="result-area">
        <div class="calc-grid" id="calc-output">
            <div style="grid-column: 1/4; text-align: center; color: #666;">
                값을 입력하면 실시간으로 계산됩니다
            </div>
        </div>
    </div>
</div>

<script>
    /* 
       순수 JS 구현 (BigInt 사용으로 64비트 완벽 지원)
       외부 라이브러리 없음
    */

    let currentMode = 'BIN'; 
    
    // DOM Elements
    const inputA = document.getElementById('inputA');
    const inputB = document.getElementById('inputB');
    const operator = document.getElementById('operator');
    const byteSize = document.getElementById('byteSize');
    const rowInputB = document.getElementById('row-inputB');
    const outputDiv = document.getElementById('calc-output');
    const btnBin = document.getElementById('btn-bin');
    const btnDec = document.getElementById('btn-dec');

    function init() {
        inputA.addEventListener('input', handleInput);
        inputB.addEventListener('input', handleInput);
        operator.addEventListener('change', () => {
            handleOperatorChange();
            calculate();
        });
        byteSize.addEventListener('change', calculate);
        
        handleOperatorChange(); // Init UI state
    }

    function handleInput(e) {
        const el = e.target;
        // 입력 제한
        if (currentMode === 'BIN') {
            el.value = el.value.replace(/[^01]/g, '');
        } else {
            el.value = el.value.replace(/[^0-9]/g, '');
        }
        calculate();
    }

    function handleOperatorChange() {
        const op = operator.value;
        if (op === '~') {
            inputB.disabled = true;
            inputB.value = '';
            rowInputB.style.opacity = '0.5';
        } else {
            inputB.disabled = false;
            rowInputB.style.opacity = '1';
        }
    }

    function setMode(mode) {
        if (currentMode === mode) return;
        
        // 값 변환 시도
        convertValue(inputA, currentMode, mode);
        convertValue(inputB, currentMode, mode);

        currentMode = mode;

        // 스타일 및 Placeholder 변경
        if (mode === 'BIN') {
            btnBin.classList.add('active');
            btnDec.classList.remove('active');
            inputA.placeholder = "0 또는 1";
            inputB.placeholder = "0 또는 1";
        } else {
            btnDec.classList.add('active');
            btnBin.classList.remove('active');
            inputA.placeholder = "0-9";
            inputB.placeholder = "0-9";
        }
        calculate();
    }

    function convertValue(el, from, to) {
        if (!el.value) return;
        try {
            // BigInt로 파싱하여 변환
            let val;
            if (from === 'BIN') val = BigInt(`0b${el.value}`);
            else val = BigInt(el.value);
            
            if (to === 'BIN') el.value = val.toString(2);
            else el.value = val.toString(10);
        } catch (e) {
            el.value = "";
        }
    }

    function calculate() {
        const op = operator.value;
        const bits = parseInt(byteSize.value);
        
        // 마스크 생성 (예: 8bit -> 11111111)
        // BigInt는 shift 연산시 BigInt끼리만 가능
        const bitsBI = BigInt(bits);
        const mask = (1n << bitsBI) - 1n;

        let valA = inputA.value;
        let valB = inputB.value;

        if (!valA && (!valB && op !== '~')) {
            outputDiv.innerHTML = '<div style="grid-column: 1/4; text-align: center; color: #666;">값을 입력하세요</div>';
            return;
        }

        try {
            // 1. 입력값 파싱 (BigInt 사용)
            let bigA = 0n, bigB = 0n;

            if (valA) bigA = currentMode === 'BIN' ? BigInt(`0b${valA}`) : BigInt(valA);
            if (valB) bigB = currentMode === 'BIN' ? BigInt(`0b${valB}`) : BigInt(valB);

            // 2. 입력값 마스킹 (선택한 바이트 크기를 넘어가면 자름 effectively overflow)
            // 이는 사용자에게 해당 비트 환경에서의 동작을 보여주기 위함입니다.
            // 다만 입력 필드의 값 자체를 바꾸진 않고 계산/출력시에만 적용합니다.
            const maskedA = bigA & mask;
            const maskedB = bigB & mask;

            let result = 0n;

            // 3. 연산 수행
            switch (op) {
                case '&': result = maskedA & maskedB; break;
                case '|': result = maskedA | maskedB; break;
                case '^': result = maskedA ^ maskedB; break;
                case '~': result = ~maskedA; break;
                case '<<': 
                    // shift amount는 마스킹 하지 않고 그대로 쓰거나, 
                    // JS 스펙상 low bits만 쓰지만 여기선 그대로 둡니다.
                    result = maskedA << maskedB; 
                    break;
                case '>>': 
                    result = maskedA >> maskedB; 
                    break;
            }

            // 4. 결과 마스킹 (오버플로우 처리 및 NOT 연산시 앞쪽 1 제거)
            const finalResult = result & mask;

            render(op, maskedA, maskedB, finalResult, bits);

        } catch (e) {
            // 파싱 중 뭔가 잘못 입력된 경우 (아직 입력 중일 때 등)
            // console.error(e);
        }
    }

    function render(op, a, b, res, bits) {
        let html = '';

        // NOT 연산은 단항 연산
        if (op === '~') {
            // A 출력
            html += createRow('', a, bits);
            // 연산자 표시
            html += `<div class="col-op">${op}</div><div class="col-bin"></div><div class="col-dec"></div>`;
        } else {
            html += createRow('', a, bits);
            html += createRow(op, b, bits);
        }

        html += `<div class="divider"></div>`;
        html += createRow('=', res, bits, true);
        
        outputDiv.innerHTML = html;
    }

    function createRow(opSymbol, val, bits, isResult = false) {
        // 2진수 변환 및 패딩 (0 채우기)
        let binStr = val.toString(2);
        
        // 비트 수만큼 0 채우기 (padStart)
        // 결과값이 bits보다 길 수 없음 (masking 했으므로)
        if (binStr.length < bits) {
            binStr = binStr.padStart(bits, '0');
        }

        // 가독성을 위해 4자리마다 띄어쓰기 추가 (선택사항)
        // 정규식: 뒤에서부터 4자리마다 공백 삽입
        const formattedBin = binStr.replace(/(?=(?:.{4})+$)/g, ' ');

        const decStr = isResult ? `= ${val.toString(10)}` : `(${val.toString(10)})`;
        const rowClass = isResult ? 'result-row' : '';

        return `
            <div class="col-op ${rowClass}">${opSymbol}</div>
            <div class="col-bin ${rowClass}">${formattedBin}</div>
            <div class="col-dec ${rowClass}">${decStr}</div>
        `;
    }

    init();
</script>

</body>
</html>
